{"mappings":"AG2EO,SAAS,EAAU,CAAmB,CAAE,CAAmB,EAChE,MAAO,CACL,EAAG,EAAO,CAAC,CAAG,EAAO,CAAC,CACtB,EAAG,EAAO,CAAC,CAAG,EAAO,CAAC,AACxB,CACF,CASO,SAAS,EAAgB,CAAgC,EAC9D,IAAM,EAAS,KAAK,IAAI,CAAC,EAAO,CAAC,EAAI,EAAI,EAAO,CAAC,EAAI,GACrD,GAAI,AAAW,IAAX,EACF,MAAM,AAAI,MAAM,kCAGlB,MAAO,CACL,EAAG,EAAO,CAAC,CAAG,EACd,EAAG,EAAO,CAAC,CAAG,CAChB,CACF,CAaA,IAAA,EAAe,CACb,KA1GK,SACL,CAAa,CACb,CAAa,CACb,CAAa,CACb,CAAc,CACd,CAAc,EAEd,MAAO,AAAE,CAAA,EAAQ,CAAA,EAAU,CAAA,EAAS,CAAA,EAAY,CAAA,EAAQ,CAAA,EAAS,CACnE,EAoGE,sBA9FK,SAA+B,CAAS,EAC7C,OAAO,MAAM,IAAI,CAAC,EAAG,OACvB,EA6FE,gBA3FK,SACL,CAAoB,CACpB,CAA6B,EAE7B,OAAO,EAAI,CAAC,GAAK,EAAa,CAAC,EAAI,EAAI,CAAC,GAAK,EAAa,CAAC,AAC7D,EAuFE,sBArFK,SACL,CAAoB,CACpB,CAA6B,EAE7B,OAAO,AAAQ,GAAR,EAAI,CAAC,GAAU,EAAa,CAAC,EAAI,AAAQ,GAAR,EAAI,CAAC,GAAU,EAAa,CAAC,AACvE,EAiFE,yCA/EK,SAAkD,CAAa,EACpE,IAAI,EAAS,CAAC,CAAG,CAAC,EAAE,CAAC,CACrB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAI,MAAM,CAAE,IAC1B,CAAG,CAAC,EAAE,GAAK,CAAM,CAAC,EAAO,MAAM,CAAG,EAAE,EACtC,EAAO,IAAI,CAAC,CAAG,CAAC,EAAE,EAGtB,OAAO,CACT,EAwEE,sBAtEK,SAA+B,CAAa,EACjD,IAAM,EAA8B,EAAE,CAClC,EAAwC,CAAE,MAAO,EAAG,UAAW,CAAE,EAWrE,OAVA,EAAI,UAAU,GAAG,OAAO,CAAC,CAAC,EAAO,EAAO,KAClC,IAAU,CAAa,CAAC,EAAQ,EAAE,EACpC,EAAmB,KAAK,CAAG,EAC3B,EAAmB,SAAS,IACnB,EAAmB,SAAS,CAAG,IACxC,EAAO,IAAI,CAAC,GACZ,EAAqB,CAAE,MAAO,EAAG,UAAW,CAAE,EAElD,GAEO,CACT,EA0DE,UAAA,EAEA,gBAAA,EACA,mCAvBK,SACL,CAAmB,CACnB,CAAmB,MArBkB,EAuBrC,OAAO,EAtBA,CACL,EAAG,AAAW,GAAX,CAFgC,EAuBS,EAAU,EAAQ,IArBpD,CAAC,CACX,EAAG,EAAO,CAAC,AACb,EAoBF,EAmBE,oBAjBK,SAA6B,CAAmB,CAAE,CAAmB,EAC1E,OAAO,EAAO,CAAC,GAAK,EAAO,CAAC,EAAI,EAAO,CAAC,GAAK,EAAO,CAAC,AACvD,CAgBA,EF5HA,MAAM,EAAS,SAAS,aAAa,CAAC,WAChC,EAAM,EAAO,UAAU,CAAC,MACxB,EAAc,SAAS,aAAa,CAAC,iBAE3C,GAAI,EAAK,CACP,IAAM,EAAc,ICCf,MACG,GAA8B,AAC/B,CAAA,gBAA8B,AAE7B,CAAA,OAAiB,AACjB,CAAA,MAAgB,AAChB,CAAA,MAAgB,AAChB,CAAA,WAAqB,AACrB,CAAA,UAAoB,AAEpB,CAAA,YAAwB,EAAE,AAAC,AAC3B,CAAA,kBAAmC,EAAE,AAAC,AACtC,CAAA,iBAAsC,EAAE,AAAC,AACzC,CAAA,mBAA0C,EAAE,AAAC,AAE7C,CAAA,QAAwB,CAC9B,mBAAoB,CAAA,EACpB,UAAW,CACb,CAAE,AAEM,CAAA,MAAQ,CACd,oBAAqB,2BACrB,iBAAkB,GAClB,YAAa,YACb,UAAW,EACX,wBAAyB,GACzB,8BAA+B,GAC/B,kBAAmB,CACrB,CAAE,AAEF,aACE,CAA6B,CAC7B,CAAc,CACd,CAAa,CACb,EAAgC,CAAE,EAAG,EAAG,EAAG,CAAE,CAAC,CAC9C,CAA8B,CAC9B,CACA,IAAI,CAAC,GAAG,CAAG,EACX,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,CAAC,KAAK,CAAG,EACb,IAAI,CAAC,gBAAgB,CAAG,EAExB,IAAI,CAAC,OAAO,CAAG,CACb,GAAG,IAAI,CAAC,OAAO,CACf,GAAG,CAAO,AACZ,CACF,CAEA,IAAI,OAAO,CAAa,CAAE,CACxB,IAAI,CAAC,OAAO,CAAG,EACf,IAAI,CAAC,WAAW,CAAG,KAAK,KAAK,CAAC,EAAQ,EACxC,CAEA,IAAI,MAAM,CAAa,CAAE,CACvB,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,CAAC,UAAU,CAAG,KAAK,KAAK,CAAC,EAAQ,EACvC,CAEA,IAAI,QAAS,CACX,OAAO,IAAI,CAAC,OAAO,AACrB,CAEA,IAAI,OAAQ,CACV,OAAO,IAAI,CAAC,MAAM,AACpB,CAEA,IAAI,OAAO,CAAa,CAAE,CACxB,IAAI,CAAC,MAAM,CAAG,EAAM,KAAK,CAAC,EAAG,IAAI,CAAC,OAAO,CAAC,SAAS,EACnD,IAAI,CAAC,WAAW,CAAG,AAAA,EAAQ,qBAAqB,CAAC,IAAI,CAAC,MAAM,EAC5D,IAAI,CAAC,iBAAiB,CAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,AAAC,GAC7C,IAAI,CAAC,mBAAmB,CAAC,IAE3B,IAAI,CAAC,gBAAgB,CAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,EAAI,EAAO,IACvD,AAAI,IAAU,EAAI,MAAM,CAAG,EAClB,CAAE,EAAG,EAAG,EAAG,CAAE,EAGf,IAAI,CAAC,kBAAkB,CAAC,EAAI,CAAG,CAAC,EAAQ,EAAE,GAGnD,IAAI,CAAC,kBAAkB,CAAG,AAAA,EAAQ,qBAAqB,CAAC,IAAI,CAAC,WAAW,CAC1E,CAEA,IAAI,QAAS,CACX,OAAO,IAAI,CAAC,MAAM,AACpB,CAEO,MAAO,CAYZ,GAXA,IAAI,CAAC,GAAG,CAAC,SAAS,CAChB,IAAI,CAAC,gBAAgB,CAAC,CAAC,CACvB,IAAI,CAAC,gBAAgB,CAAC,CAAC,CACvB,IAAI,CAAC,KAAK,CACV,IAAI,CAAC,MAAM,EAGT,IAAI,CAAC,OAAO,CAAC,kBAAkB,EACjC,IAAI,CAAC,eAAe,GAGlB,CAAC,IAAI,CAAC,MAAM,CACd,MAAM,AAAI,MACR,+DAIJ,GACE,AAAmC,IAAnC,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAC9B,IAAI,CAAC,kBAAkB,CAAC,EAAE,CAAC,SAAS,GAAK,IAAI,CAAC,OAAO,CAAC,SAAS,CAAG,EAClE,CAEA,IAAM,EAAc,IAAI,CAAC,yBAAyB,GAClD,IAAI,CAAC,GAAG,CAAC,SAAS,GAClB,IAAI,CAAC,GAAG,CAAC,GAAG,CACV,EAAY,CAAC,CACb,EAAY,CAAC,CACb,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAC5B,EACA,EAAI,KAAK,EAAE,EAEb,IAAI,CAAC,GAAG,CAAC,SAAS,CAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAC3C,IAAI,CAAC,GAAG,CAAC,IAAI,GACb,IAAI,CAAC,GAAG,CAAC,SAAS,EACpB,CAGA,IAAI,CAAC,GAAG,CAAC,WAAW,CAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAC7C,IAAI,CAAC,GAAG,CAAC,SAAS,CAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CACzC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAG,QACnB,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAG,QACpB,IAAI,CAAC,GAAG,CAAC,SAAS,GAElB,AAAA,EAAQ,wCAAwC,CAAC,IAAI,CAAC,WAAW,EAAE,OAAO,CACxE,CAAC,EAAO,KACN,IAAM,EAAc,IAAI,CAAC,mBAAmB,CAAC,EACzC,AAAU,CAAA,IAAV,EACF,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,EAAY,CAAC,CAAE,EAAY,CAAC,EAE5C,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,EAAY,CAAC,CAAE,EAAY,CAAC,CAEhD,GAEF,IAAI,CAAC,GAAG,CAAC,MAAM,GACf,IAAI,CAAC,GAAG,CAAC,SAAS,GAGlB,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,EAAO,KAC/B,GACE,AAAU,IAAV,GACA,AAAA,EAAQ,eAAe,CACrB,IAAI,CAAC,gBAAgB,CAAC,EAAM,CAC5B,IAAI,CAAC,gBAAgB,CAAC,EAAQ,EAAE,GAElC,IAAU,IAAI,CAAC,WAAW,CAAC,EAAQ,EAAE,CACrC,CACA,IAAM,EAAc,IAAI,CAAC,mBAAmB,CAAC,GACvC,EAAkB,IAAI,CAAC,mBAAmB,CAC9C,IAAI,CAAC,WAAW,CAAC,EAAQ,EAAE,EAGvB,EACJ,AAAA,EAAQ,kCAAkC,CACxC,EACA,GAGJ,IAAI,CAAC,GAAG,CAAC,SAAS,GAClB,IAAI,CAAC,GAAG,CAAC,OAAO,CAAG,OACnB,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAG,QACpB,IAAI,CAAC,GAAG,CAAC,MAAM,CACb,EAAY,CAAC,CACX,EAA8B,CAAC,CAC7B,IAAI,CAAC,KAAK,CAAC,uBAAuB,CACtC,EAAY,CAAC,CACX,EAA8B,CAAC,CAAG,IAAI,CAAC,KAAK,CAAC,uBAAuB,EAExE,IAAI,CAAC,GAAG,CAAC,MAAM,CACb,EAAY,CAAC,CACX,EAA8B,CAAC,CAC7B,IAAI,CAAC,KAAK,CAAC,uBAAuB,CACtC,EAAY,CAAC,CACX,EAA8B,CAAC,CAAG,IAAI,CAAC,KAAK,CAAC,uBAAuB,EAExE,IAAI,CAAC,GAAG,CAAC,MAAM,GACf,IAAI,CAAC,GAAG,CAAC,SAAS,GAElB,IAAI,CAAC,GAAG,CAAC,OAAO,CAAG,QACnB,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAG,QAEpB,IAAI,CAAC,GAAG,CAAC,MAAM,CACb,IAAI,CAAC,iBAAiB,CAAC,EAAQ,EAAE,CAAC,CAAC,CACnC,IAAI,CAAC,iBAAiB,CAAC,EAAQ,EAAE,CAAC,CAAC,CAEvC,CACF,GAGA,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,AAAC,IAC/B,IAAM,EAAc,IAAI,CAAC,mBAAmB,CAAC,EAAQ,KAAK,EAE1D,IAAI,CAAC,GAAG,CAAC,SAAS,GAClB,IAAI,CAAC,GAAG,CAAC,GAAG,CACV,EAAY,CAAC,CACb,EAAY,CAAC,CACb,IAAI,CAAC,KAAK,CAAC,6BAA6B,CACxC,EACA,EAAI,KAAK,EAAE,EAEb,IAAI,CAAC,GAAG,CAAC,MAAM,GACf,IAAI,CAAC,GAAG,CAAC,SAAS,GAEd,EAAQ,SAAS,EAAI,IACvB,IAAI,CAAC,GAAG,CAAC,SAAS,GAClB,IAAI,CAAC,GAAG,CAAC,MAAM,CACb,EAAY,CAAC,CAAG,IAAI,CAAC,KAAK,CAAC,6BAA6B,CACxD,EAAY,CAAC,EAEf,IAAI,CAAC,GAAG,CAAC,MAAM,CACb,EAAY,CAAC,CAAG,IAAI,CAAC,KAAK,CAAC,6BAA6B,CACxD,EAAY,CAAC,EAEf,IAAI,CAAC,GAAG,CAAC,MAAM,GACf,IAAI,CAAC,GAAG,CAAC,SAAS,IAGhB,EAAQ,SAAS,EAAI,IACvB,IAAI,CAAC,GAAG,CAAC,SAAS,GAClB,IAAI,CAAC,GAAG,CAAC,MAAM,CACb,EAAY,CAAC,CACb,EAAY,CAAC,CAAG,IAAI,CAAC,KAAK,CAAC,6BAA6B,EAE1D,IAAI,CAAC,GAAG,CAAC,MAAM,CACb,EAAY,CAAC,CACb,EAAY,CAAC,CAAG,IAAI,CAAC,KAAK,CAAC,6BAA6B,EAE1D,IAAI,CAAC,GAAG,CAAC,MAAM,GACf,IAAI,CAAC,GAAG,CAAC,SAAS,GAEtB,GAGA,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC,EAAW,KACxC,GAAI,AAAU,IAAV,GAAe,IAAU,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAG,GAK1D,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,EAAG,GAAO,IAAI,CAAC,AAAC,GACnC,AAAA,EAAQ,qBAAqB,CAAC,EAAW,IAElD,CACA,IAAM,EAAc,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,WAAW,CAAC,EAAM,EAC9D,EAAiB,IAAI,CAAC,mBAAmB,CAC7C,IAAI,CAAC,WAAW,CAAC,EAAQ,EAAE,EAGvB,EAAU,AAAgB,IAAhB,EAAU,CAAC,CAAS,GAAK,EAAU,CAAC,CAAG,EACjD,EAAU,AAAY,IAAZ,EAAgB,IAAM,EAAU,CAAC,CAAG,EAEpD,IAAI,CAAC,GAAG,CAAC,SAAS,GAClB,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,EAAY,CAAC,CAAG,EAAS,EAAY,CAAC,CAAG,GAEzD,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,EAAe,CAAC,CAAG,EAAS,EAAe,CAAC,CAAG,GAE/D,IAAI,CAAC,GAAG,CAAC,MAAM,GACf,IAAI,CAAC,GAAG,CAAC,SAAS,EACpB,CACF,EACF,CAEQ,iBAAkB,CACxB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAG,IAAK,CAC1B,IAAM,EACJ,IAAI,CAAC,gBAAgB,CAAC,CAAC,CACvB,IAAI,CAAC,UAAU,CAAI,CAAA,EAAI,CAAA,EACvB,IAAI,CAAC,UAAU,CAAG,EACd,EACJ,IAAI,CAAC,gBAAgB,CAAC,CAAC,CACvB,IAAI,CAAC,WAAW,CAAG,KAAK,KAAK,CAAC,EAAI,GAClC,IAAI,CAAC,WAAW,CAAG,EAErB,IAAI,CAAC,GAAG,CAAC,SAAS,GAClB,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAG,EAAG,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAE,EAAG,EAAI,KAAK,EAAE,EAC9D,IAAI,CAAC,GAAG,CAAC,SAAS,CAAG,IAAI,CAAC,KAAK,CAAC,mBAAmB,CACnD,IAAI,CAAC,GAAG,CAAC,IAAI,EACf,CAGA,IAAM,EAAI,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAG,IAAI,CAAC,UAAU,CAAG,IAAI,CAAC,UAAU,CAAG,EAClE,EACJ,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAG,AAAmB,EAAnB,IAAI,CAAC,WAAW,CAAO,IAAI,CAAC,WAAW,CAAG,EACtE,IAAI,CAAC,GAAG,CAAC,SAAS,GAClB,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAG,EAAG,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAE,EAAG,EAAI,KAAK,EAAE,EAC9D,IAAI,CAAC,GAAG,CAAC,SAAS,CAAG,IAAI,CAAC,KAAK,CAAC,mBAAmB,CACnD,IAAI,CAAC,GAAG,CAAC,IAAI,EACf,CAEQ,oBAAoB,CAAW,CAAe,CACpD,IAAM,EAAS,AAAA,EAAQ,IAAI,CAAC,EAAK,EAAG,EAAG,EAAG,UAE1C,AAAI,AAAQ,IAAR,EACK,CACL,EAAG,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAG,IAAI,CAAC,UAAU,CAAG,IAAI,CAAC,UAAU,CAAG,EACjE,EACE,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAG,AAAmB,EAAnB,IAAI,CAAC,WAAW,CAAO,IAAI,CAAC,WAAW,CAAG,CACxE,EAGK,CACL,EACE,IAAI,CAAC,gBAAgB,CAAC,CAAC,CACvB,IAAI,CAAC,UAAU,CAAI,CAAA,AAAC,CAAA,EAAM,CAAA,EAAK,CAAA,EAC/B,IAAI,CAAC,UAAU,CAAG,EACpB,EACE,IAAI,CAAC,gBAAgB,CAAC,CAAC,CACvB,IAAI,CAAC,WAAW,CAAG,KAAK,KAAK,CAAC,EAAS,GACvC,IAAI,CAAC,WAAW,CAAG,CACvB,CACF,CAEQ,mBACN,CAAa,CACb,CAAiB,CACA,CACjB,IAAM,EAAQ,IAAI,CAAC,mBAAmB,CAAC,GACjC,EAAY,IAAI,CAAC,mBAAmB,CAAC,GAE3C,MAAO,CACL,EAAG,KAAK,IAAI,CAAC,EAAU,CAAC,CAAG,EAAM,CAAC,GAAK,EACvC,EAAG,KAAK,IAAI,CAAC,EAAU,CAAC,CAAG,EAAM,CAAC,GAAK,CACzC,CACF,CAEQ,2BAAyC,CAC/C,IAAM,EAAa,IAAI,CAAC,iBAAiB,CAAC,EAAE,CACtC,EACJ,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,AAAC,GACpB,CAAC,AAAA,EAAQ,mBAAmB,CAAC,EAAY,KAC5C,IAAI,CAAC,iBAAiB,CAAC,EAAE,CAE3B,EAAS,AAAA,EAAQ,eAAe,CACpC,AAAA,EAAQ,SAAS,CAAC,EAAY,IAGhC,MAAO,CACL,EAAG,EAAW,CAAC,CAAG,CAAA,CAAA,EAAO,CAAC,CAAG,IAAI,CAAC,KAAK,CAAC,uBAAuB,CAAG,CAAlE,EACA,EAAG,EAAW,CAAC,CAAG,CAAA,CAAA,EAAO,CAAC,CAAG,IAAI,CAAC,KAAK,CAAC,uBAAuB,CAAG,CAAlE,CACF,CACF,CACF,ED5VI,EACA,EAAO,YAAY,CACnB,EAAO,WAAW,CAClB,CAAE,EAAG,EAAG,EAAG,CAAE,EACb,CACE,mBAAoB,CAAA,CACtB,GAGF,EAAY,gBAAgB,CAAC,QAAS,AAAC,IACrC,EAAY,KAAK,CAAG,EAAE,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,UAAW,GACxD,GAEA,EAAY,gBAAgB,CAAC,SAAU,AAAC,IACtC,EAAY,MAAM,CAAG,EAAE,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,UAAW,IACvD,EAAY,IAAI,EAClB,EACF","sources":["<anon>","src/app.ts","src/glyph.ts","src/helpers.ts"],"sourcesContent":["function $3c260e55dc652601$export$3a89f8d6f6bf6c9f(value, inMin, inMax, outMin, outMax) {\n    return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n}\nfunction $3c260e55dc652601$export$f9bc3c322ccc34d7(n) {\n    return Array.from(String(n), Number);\n}\nfunction $3c260e55dc652601$export$18d7a4caa19f39da(n) {\n    return Array.from(n, Number);\n}\nfunction $3c260e55dc652601$export$e1efbfa5a70bc185(dir, dirToCompare) {\n    return dir.x === dirToCompare.x && dir.y === dirToCompare.y;\n}\nfunction $3c260e55dc652601$export$140e588d6a1e19dc(dir, dirToCompare) {\n    return dir.x * -1 === dirToCompare.x && dir.y * -1 === dirToCompare.y;\n}\nfunction $3c260e55dc652601$export$d11e6f7940edaeb(arr) {\n    let result = [\n        arr[0]\n    ];\n    for(let i = 1; i < arr.length; i++)if (arr[i] !== result[result.length - 1]) result.push(arr[i]);\n    return result;\n}\nfunction $3c260e55dc652601$export$51e88bcab11c2d0e(arr) {\n    const result = [];\n    let currentConsecutive = {\n        digit: 0,\n        occurence: 0\n    };\n    arr.toReversed().forEach((digit, index, reversedArray)=>{\n        if (digit === reversedArray[index + 1]) {\n            currentConsecutive.digit = digit;\n            currentConsecutive.occurence++;\n        } else if (currentConsecutive.occurence > 0) {\n            result.push(currentConsecutive);\n            currentConsecutive = {\n                digit: 0,\n                occurence: 0\n            };\n        }\n    });\n    return result;\n}\nfunction $3c260e55dc652601$export$f9f3202f262fc8fc(direction) {\n    // If x and y are both 0, there's no perpendicular direction\n    if (direction.x === 0 && direction.y === 0) throw new Error(\"Input direction cannot be (0, 0)\");\n    // Perpendicular direction to (x, y) is (-y, x)\n    return {\n        x: -direction.y,\n        y: direction.x\n    };\n}\nfunction $3c260e55dc652601$export$99d5dab9b950a0b4(coord1, coord2) {\n    return {\n        x: coord2.x - coord1.x,\n        y: coord2.y - coord1.y\n    };\n}\nfunction $3c260e55dc652601$export$841b9d7c3bc32bb7(vector) {\n    return {\n        x: vector.y * -1,\n        y: vector.x\n    };\n}\nfunction $3c260e55dc652601$export$4d973b3eababff1d(vector) {\n    const length = Math.sqrt(vector.x ** 2 + vector.y ** 2);\n    if (length === 0) throw new Error(\"Cannot normalize a zero vector\");\n    return {\n        x: vector.x / length,\n        y: vector.y / length\n    };\n}\nfunction $3c260e55dc652601$export$203c1b75145b5405(coord1, coord2) {\n    return $3c260e55dc652601$export$4d973b3eababff1d($3c260e55dc652601$export$841b9d7c3bc32bb7($3c260e55dc652601$export$99d5dab9b950a0b4(coord1, coord2)));\n}\nfunction $3c260e55dc652601$export$7dcfe024f86cf91b(coord1, coord2) {\n    return coord1.x === coord2.x && coord1.y === coord2.y;\n}\nvar $3c260e55dc652601$export$2e2bcd8739ae039 = {\n    lerp: $3c260e55dc652601$export$3a89f8d6f6bf6c9f,\n    splitNumberIntoDigits: $3c260e55dc652601$export$f9bc3c322ccc34d7,\n    splitStringIntoDigits: $3c260e55dc652601$export$18d7a4caa19f39da,\n    isSameDirection: $3c260e55dc652601$export$e1efbfa5a70bc185,\n    isOppositiveDirection: $3c260e55dc652601$export$140e588d6a1e19dc,\n    generateArrayWithDifferentAdjacentDigits: $3c260e55dc652601$export$d11e6f7940edaeb,\n    getConsecutiveNumbers: $3c260e55dc652601$export$51e88bcab11c2d0e,\n    getPerpendicularDirection: $3c260e55dc652601$export$f9f3202f262fc8fc,\n    getVector: $3c260e55dc652601$export$99d5dab9b950a0b4,\n    getPerpendicularVector: $3c260e55dc652601$export$841b9d7c3bc32bb7,\n    normalizeVector: $3c260e55dc652601$export$4d973b3eababff1d,\n    getNormalizedVectorFromCoordinates: $3c260e55dc652601$export$203c1b75145b5405,\n    areCoordinatesEqual: $3c260e55dc652601$export$7dcfe024f86cf91b\n};\n\n\nclass $b36a0c8d207f18a7$export$408bb2acbb28390c {\n    ctx;\n    startCoordinates;\n    _height;\n    _width;\n    _digit;\n    blockHeight;\n    blockWidth;\n    digitsArray = [];\n    digitsCoordinates = [];\n    digitsDirections = [];\n    consecutiveNumbers = [];\n    options = {\n        displayHelpCircles: false,\n        maxDigits: 4\n    };\n    style = {\n        helpCircleFillStyle: \"rgba(191, 191, 191, 0.1)\",\n        helpCircleRadius: 10,\n        strokeStyle: \"indianred\",\n        lineWidth: 5,\n        sameDirectionLineLength: 10,\n        consecutiveNumberCircleRadius: 15,\n        smallCircleRadius: 5\n    };\n    constructor(ctx, height, width, startCoordinates = {\n        x: 0,\n        y: 0\n    }, options){\n        this.ctx = ctx;\n        this.height = height;\n        this.width = width;\n        this.startCoordinates = startCoordinates;\n        this.options = {\n            ...this.options,\n            ...options\n        };\n    }\n    set height(value) {\n        this._height = value;\n        this.blockHeight = Math.floor(value / 4);\n    }\n    set width(value) {\n        this._width = value;\n        this.blockWidth = Math.floor(value / 3);\n    }\n    get height() {\n        return this._height;\n    }\n    get width() {\n        return this._width;\n    }\n    set number(value) {\n        this._digit = value.slice(0, this.options.maxDigits);\n        this.digitsArray = (0, $3c260e55dc652601$export$2e2bcd8739ae039).splitStringIntoDigits(this.number);\n        this.digitsCoordinates = this.digitsArray.map((el)=>this.getNumberCoordinate(el));\n        this.digitsDirections = this.digitsArray.map((el, index, arr)=>{\n            if (index === arr.length - 1) return {\n                x: 0,\n                y: 0\n            };\n            return this.getNumberDirection(el, arr[index + 1]);\n        });\n        this.consecutiveNumbers = (0, $3c260e55dc652601$export$2e2bcd8739ae039).getConsecutiveNumbers(this.digitsArray);\n    }\n    get number() {\n        return this._digit;\n    }\n    draw() {\n        this.ctx.clearRect(this.startCoordinates.x, this.startCoordinates.y, this.width, this.height);\n        if (this.options.displayHelpCircles) this.drawHelpCircles();\n        if (!this._digit) throw new Error(\"Glyph cannot be draw without setting number property first.\");\n        if (this.consecutiveNumbers.length !== 1 || this.consecutiveNumbers[0].occurence !== this.options.maxDigits - 1) {\n            // Draw small circle\n            const circleCoord = this.getStartCircleCoordinates();\n            this.ctx.beginPath();\n            this.ctx.arc(circleCoord.x, circleCoord.y, this.style.smallCircleRadius, 0, 2 * Math.PI);\n            this.ctx.fillStyle = this.style.strokeStyle;\n            this.ctx.fill();\n            this.ctx.closePath();\n        }\n        // Set line styles\n        this.ctx.strokeStyle = this.style.strokeStyle;\n        this.ctx.lineWidth = this.style.lineWidth;\n        this.ctx.lineCap = \"round\";\n        this.ctx.lineJoin = \"round\";\n        this.ctx.beginPath();\n        // Draw all the lines first\n        (0, $3c260e55dc652601$export$2e2bcd8739ae039).generateArrayWithDifferentAdjacentDigits(this.digitsArray).forEach((digit, index)=>{\n            const coordinates = this.getNumberCoordinate(digit);\n            if (index === 0) this.ctx.moveTo(coordinates.x, coordinates.y);\n            else this.ctx.lineTo(coordinates.x, coordinates.y);\n        });\n        this.ctx.stroke();\n        this.ctx.closePath();\n        // Draw same directions\n        this.digitsArray.forEach((digit, index)=>{\n            if (index !== 0 && (0, $3c260e55dc652601$export$2e2bcd8739ae039).isSameDirection(this.digitsDirections[index], this.digitsDirections[index - 1]) && digit !== this.digitsArray[index - 1]) {\n                const coordinates = this.getNumberCoordinate(digit);\n                const nextCoordinates = this.getNumberCoordinate(this.digitsArray[index + 1]);\n                const normalizedPerpendicularVector = (0, $3c260e55dc652601$export$2e2bcd8739ae039).getNormalizedVectorFromCoordinates(coordinates, nextCoordinates);\n                this.ctx.beginPath();\n                this.ctx.lineCap = \"butt\";\n                this.ctx.lineJoin = \"miter\";\n                this.ctx.moveTo(coordinates.x + normalizedPerpendicularVector.x * this.style.sameDirectionLineLength, coordinates.y + normalizedPerpendicularVector.y * this.style.sameDirectionLineLength);\n                this.ctx.lineTo(coordinates.x - normalizedPerpendicularVector.x * this.style.sameDirectionLineLength, coordinates.y - normalizedPerpendicularVector.y * this.style.sameDirectionLineLength);\n                this.ctx.stroke();\n                this.ctx.closePath();\n                this.ctx.lineCap = \"round\";\n                this.ctx.lineJoin = \"round\";\n                this.ctx.moveTo(this.digitsCoordinates[index - 1].x, this.digitsCoordinates[index - 1].y);\n            }\n        });\n        // Draw circle on consecutive numbers\n        this.consecutiveNumbers.forEach((element)=>{\n            const coordinates = this.getNumberCoordinate(element.digit);\n            this.ctx.beginPath();\n            this.ctx.arc(coordinates.x, coordinates.y, this.style.consecutiveNumberCircleRadius, 0, 2 * Math.PI);\n            this.ctx.stroke();\n            this.ctx.closePath();\n            if (element.occurence >= 2) {\n                this.ctx.beginPath();\n                this.ctx.moveTo(coordinates.x - this.style.consecutiveNumberCircleRadius, coordinates.y);\n                this.ctx.lineTo(coordinates.x + this.style.consecutiveNumberCircleRadius, coordinates.y);\n                this.ctx.stroke();\n                this.ctx.closePath();\n            }\n            if (element.occurence >= 3) {\n                this.ctx.beginPath();\n                this.ctx.moveTo(coordinates.x, coordinates.y - this.style.consecutiveNumberCircleRadius);\n                this.ctx.lineTo(coordinates.x, coordinates.y + this.style.consecutiveNumberCircleRadius);\n                this.ctx.stroke();\n                this.ctx.closePath();\n            }\n        });\n        // Draw lines that goes in inverted directions\n        this.digitsDirections.forEach((direction, index)=>{\n            if (index === 0 || index === this.digitsDirections.length - 1) return;\n            if (this.digitsDirections.slice(0, index).some((dd)=>{\n                return (0, $3c260e55dc652601$export$2e2bcd8739ae039).isOppositiveDirection(direction, dd);\n            })) {\n                const coordinates = this.getNumberCoordinate(this.digitsArray[index]);\n                const endCoordinates = this.getNumberCoordinate(this.digitsArray[index + 1]);\n                const xOffset = direction.y !== 0 ? 10 * direction.y : 0;\n                const yOffset = xOffset === 0 ? -10 * direction.x : 0;\n                this.ctx.beginPath();\n                this.ctx.moveTo(coordinates.x + xOffset, coordinates.y + yOffset);\n                this.ctx.lineTo(endCoordinates.x + xOffset, endCoordinates.y + yOffset);\n                this.ctx.stroke();\n                this.ctx.closePath();\n            }\n        });\n    }\n    drawHelpCircles() {\n        for(let i = 0; i < 9; i++){\n            const x = this.startCoordinates.x + this.blockWidth * (i % 3) + this.blockWidth / 2;\n            const y = this.startCoordinates.y + this.blockHeight * Math.floor(i / 3) + this.blockHeight / 2;\n            this.ctx.beginPath();\n            this.ctx.arc(x, y, this.style.helpCircleRadius, 0, 2 * Math.PI);\n            this.ctx.fillStyle = this.style.helpCircleFillStyle;\n            this.ctx.fill();\n        }\n        // Draw 0 circle\n        const x = this.startCoordinates.x + this.blockWidth + this.blockWidth / 2;\n        const y = this.startCoordinates.y + this.blockHeight * 3 + this.blockHeight / 2;\n        this.ctx.beginPath();\n        this.ctx.arc(x, y, this.style.helpCircleRadius, 0, 2 * Math.PI);\n        this.ctx.fillStyle = this.style.helpCircleFillStyle;\n        this.ctx.fill();\n    }\n    getNumberCoordinate(num) {\n        const yIndex = (0, $3c260e55dc652601$export$2e2bcd8739ae039).lerp(num, 1, 9, 8, 0);\n        if (num === 0) return {\n            x: this.startCoordinates.x + this.blockWidth + this.blockWidth / 2,\n            y: this.startCoordinates.y + this.blockHeight * 3 + this.blockHeight / 2\n        };\n        return {\n            x: this.startCoordinates.x + this.blockWidth * ((num - 1) % 3) + this.blockWidth / 2,\n            y: this.startCoordinates.y + this.blockHeight * Math.floor(yIndex / 3) + this.blockHeight / 2\n        };\n    }\n    getNumberDirection(digit, prevDigit) {\n        const coord = this.getNumberCoordinate(digit);\n        const prevCoord = this.getNumberCoordinate(prevDigit);\n        return {\n            x: Math.sign(prevCoord.x - coord.x) ?? 0,\n            y: Math.sign(prevCoord.y - coord.y) ?? 0\n        };\n    }\n    getStartCircleCoordinates() {\n        const firstCoord = this.digitsCoordinates[0];\n        const secondCoord = this.digitsCoordinates.find((coord)=>{\n            return !(0, $3c260e55dc652601$export$2e2bcd8739ae039).areCoordinatesEqual(firstCoord, coord);\n        }) ?? this.digitsCoordinates[1];\n        const vector = (0, $3c260e55dc652601$export$2e2bcd8739ae039).normalizeVector((0, $3c260e55dc652601$export$2e2bcd8739ae039).getVector(firstCoord, secondCoord));\n        return {\n            x: firstCoord.x + vector.x * this.style.sameDirectionLineLength * -1,\n            y: firstCoord.y + vector.y * this.style.sameDirectionLineLength * -1\n        };\n    }\n}\n\n\nconst $f43313d21d3fd8e2$var$canvas = document.querySelector(\"#canvas\");\nconst $f43313d21d3fd8e2$var$ctx = $f43313d21d3fd8e2$var$canvas.getContext(\"2d\");\nconst $f43313d21d3fd8e2$var$numberInput = document.querySelector(\"#number-input\");\nif ($f43313d21d3fd8e2$var$ctx) {\n    const numberGlyph = new (0, $b36a0c8d207f18a7$export$408bb2acbb28390c)($f43313d21d3fd8e2$var$ctx, $f43313d21d3fd8e2$var$canvas.clientHeight, $f43313d21d3fd8e2$var$canvas.clientWidth, {\n        x: 0,\n        y: 0\n    }, {\n        displayHelpCircles: true\n    });\n    $f43313d21d3fd8e2$var$numberInput.addEventListener(\"input\", (e)=>{\n        $f43313d21d3fd8e2$var$numberInput.value = e.target.value.replace(/[^0-9]/g, \"\");\n    });\n    $f43313d21d3fd8e2$var$numberInput.addEventListener(\"change\", (e)=>{\n        numberGlyph.number = e.target.value.replace(/[^0-9]/g, \"\");\n        numberGlyph.draw();\n    });\n}\n\n\n//# sourceMappingURL=number-glyph.ade2e3b5.js.map\n","import { Glyph } from \"./glyph\";\n\nconst canvas = document.querySelector(\"#canvas\") as HTMLCanvasElement;\nconst ctx = canvas.getContext(\"2d\");\nconst numberInput = document.querySelector(\"#number-input\") as HTMLInputElement;\n\nif (ctx) {\n  const numberGlyph = new Glyph(\n    ctx,\n    canvas.clientHeight,\n    canvas.clientWidth,\n    { x: 0, y: 0 },\n    {\n      displayHelpCircles: true,\n    }\n  );\n\n  numberInput.addEventListener(\"input\", (e: Event) => {\n    numberInput.value = e.target.value.replace(/[^0-9]/g, \"\");\n  });\n\n  numberInput.addEventListener(\"change\", (e: Event) => {\n    numberGlyph.number = e.target.value.replace(/[^0-9]/g, \"\");\n    numberGlyph.draw();\n  });\n}\n","import Helpers from \"./helpers\";\nimport { ConsecutiveNumber, Coordinates, DirectionVector } from \"./types\";\n\ntype GlyphOptions = {\n  displayHelpCircles: boolean;\n  maxDigits: number;\n};\n\nexport class Glyph {\n  private ctx: CanvasRenderingContext2D;\n  public startCoordinates: Coordinates;\n\n  private _height!: number;\n  private _width!: number;\n  private _digit!: string;\n  private blockHeight!: number;\n  private blockWidth!: number;\n\n  private digitsArray: number[] = [];\n  private digitsCoordinates: Coordinates[] = [];\n  private digitsDirections: DirectionVector[] = [];\n  private consecutiveNumbers: ConsecutiveNumber[] = [];\n\n  private options: GlyphOptions = {\n    displayHelpCircles: false,\n    maxDigits: 4,\n  };\n\n  private style = {\n    helpCircleFillStyle: \"rgba(191, 191, 191, 0.1)\",\n    helpCircleRadius: 10,\n    strokeStyle: \"indianred\",\n    lineWidth: 5,\n    sameDirectionLineLength: 10,\n    consecutiveNumberCircleRadius: 15,\n    smallCircleRadius: 5,\n  };\n\n  constructor(\n    ctx: CanvasRenderingContext2D,\n    height: number,\n    width: number,\n    startCoordinates: Coordinates = { x: 0, y: 0 },\n    options: Partial<GlyphOptions>\n  ) {\n    this.ctx = ctx;\n    this.height = height;\n    this.width = width;\n    this.startCoordinates = startCoordinates;\n\n    this.options = {\n      ...this.options,\n      ...options,\n    };\n  }\n\n  set height(value: number) {\n    this._height = value;\n    this.blockHeight = Math.floor(value / 4);\n  }\n\n  set width(value: number) {\n    this._width = value;\n    this.blockWidth = Math.floor(value / 3);\n  }\n\n  get height() {\n    return this._height;\n  }\n\n  get width() {\n    return this._width;\n  }\n\n  set number(value: string) {\n    this._digit = value.slice(0, this.options.maxDigits);\n    this.digitsArray = Helpers.splitStringIntoDigits(this.number);\n    this.digitsCoordinates = this.digitsArray.map((el) =>\n      this.getNumberCoordinate(el)\n    );\n    this.digitsDirections = this.digitsArray.map((el, index, arr) => {\n      if (index === arr.length - 1) {\n        return { x: 0, y: 0 };\n      }\n\n      return this.getNumberDirection(el, arr[index + 1]);\n    });\n\n    this.consecutiveNumbers = Helpers.getConsecutiveNumbers(this.digitsArray);\n  }\n\n  get number() {\n    return this._digit;\n  }\n\n  public draw() {\n    this.ctx.clearRect(\n      this.startCoordinates.x,\n      this.startCoordinates.y,\n      this.width,\n      this.height\n    );\n\n    if (this.options.displayHelpCircles) {\n      this.drawHelpCircles();\n    }\n\n    if (!this._digit) {\n      throw new Error(\n        \"Glyph cannot be draw without setting number property first.\"\n      );\n    }\n\n    if (\n      this.consecutiveNumbers.length !== 1 ||\n      this.consecutiveNumbers[0].occurence !== this.options.maxDigits - 1\n    ) {\n      // Draw small circle\n      const circleCoord = this.getStartCircleCoordinates();\n      this.ctx.beginPath();\n      this.ctx.arc(\n        circleCoord.x,\n        circleCoord.y,\n        this.style.smallCircleRadius,\n        0,\n        2 * Math.PI\n      );\n      this.ctx.fillStyle = this.style.strokeStyle;\n      this.ctx.fill();\n      this.ctx.closePath();\n    }\n\n    // Set line styles\n    this.ctx.strokeStyle = this.style.strokeStyle;\n    this.ctx.lineWidth = this.style.lineWidth;\n    this.ctx.lineCap = \"round\";\n    this.ctx.lineJoin = \"round\";\n    this.ctx.beginPath();\n    // Draw all the lines first\n    Helpers.generateArrayWithDifferentAdjacentDigits(this.digitsArray).forEach(\n      (digit, index) => {\n        const coordinates = this.getNumberCoordinate(digit);\n        if (index === 0) {\n          this.ctx.moveTo(coordinates.x, coordinates.y);\n        } else {\n          this.ctx.lineTo(coordinates.x, coordinates.y);\n        }\n      }\n    );\n    this.ctx.stroke();\n    this.ctx.closePath();\n\n    // Draw same directions\n    this.digitsArray.forEach((digit, index) => {\n      if (\n        index !== 0 &&\n        Helpers.isSameDirection(\n          this.digitsDirections[index],\n          this.digitsDirections[index - 1]\n        ) &&\n        digit !== this.digitsArray[index - 1]\n      ) {\n        const coordinates = this.getNumberCoordinate(digit);\n        const nextCoordinates = this.getNumberCoordinate(\n          this.digitsArray[index + 1]\n        );\n\n        const normalizedPerpendicularVector =\n          Helpers.getNormalizedVectorFromCoordinates(\n            coordinates,\n            nextCoordinates\n          );\n\n        this.ctx.beginPath();\n        this.ctx.lineCap = \"butt\";\n        this.ctx.lineJoin = \"miter\";\n        this.ctx.moveTo(\n          coordinates.x +\n            normalizedPerpendicularVector.x *\n              this.style.sameDirectionLineLength,\n          coordinates.y +\n            normalizedPerpendicularVector.y * this.style.sameDirectionLineLength\n        );\n        this.ctx.lineTo(\n          coordinates.x -\n            normalizedPerpendicularVector.x *\n              this.style.sameDirectionLineLength,\n          coordinates.y -\n            normalizedPerpendicularVector.y * this.style.sameDirectionLineLength\n        );\n        this.ctx.stroke();\n        this.ctx.closePath();\n\n        this.ctx.lineCap = \"round\";\n        this.ctx.lineJoin = \"round\";\n\n        this.ctx.moveTo(\n          this.digitsCoordinates[index - 1].x,\n          this.digitsCoordinates[index - 1].y\n        );\n      }\n    });\n\n    // Draw circle on consecutive numbers\n    this.consecutiveNumbers.forEach((element) => {\n      const coordinates = this.getNumberCoordinate(element.digit);\n\n      this.ctx.beginPath();\n      this.ctx.arc(\n        coordinates.x,\n        coordinates.y,\n        this.style.consecutiveNumberCircleRadius,\n        0,\n        2 * Math.PI\n      );\n      this.ctx.stroke();\n      this.ctx.closePath();\n\n      if (element.occurence >= 2) {\n        this.ctx.beginPath();\n        this.ctx.moveTo(\n          coordinates.x - this.style.consecutiveNumberCircleRadius,\n          coordinates.y\n        );\n        this.ctx.lineTo(\n          coordinates.x + this.style.consecutiveNumberCircleRadius,\n          coordinates.y\n        );\n        this.ctx.stroke();\n        this.ctx.closePath();\n      }\n\n      if (element.occurence >= 3) {\n        this.ctx.beginPath();\n        this.ctx.moveTo(\n          coordinates.x,\n          coordinates.y - this.style.consecutiveNumberCircleRadius\n        );\n        this.ctx.lineTo(\n          coordinates.x,\n          coordinates.y + this.style.consecutiveNumberCircleRadius\n        );\n        this.ctx.stroke();\n        this.ctx.closePath();\n      }\n    });\n\n    // Draw lines that goes in inverted directions\n    this.digitsDirections.forEach((direction, index) => {\n      if (index === 0 || index === this.digitsDirections.length - 1) {\n        return;\n      }\n\n      if (\n        this.digitsDirections.slice(0, index).some((dd) => {\n          return Helpers.isOppositiveDirection(direction, dd);\n        })\n      ) {\n        const coordinates = this.getNumberCoordinate(this.digitsArray[index]);\n        const endCoordinates = this.getNumberCoordinate(\n          this.digitsArray[index + 1]\n        );\n\n        const xOffset = direction.y !== 0 ? 10 * direction.y : 0;\n        const yOffset = xOffset === 0 ? -10 * direction.x : 0;\n\n        this.ctx.beginPath();\n        this.ctx.moveTo(coordinates.x + xOffset, coordinates.y + yOffset);\n\n        this.ctx.lineTo(endCoordinates.x + xOffset, endCoordinates.y + yOffset);\n\n        this.ctx.stroke();\n        this.ctx.closePath();\n      }\n    });\n  }\n\n  private drawHelpCircles() {\n    for (let i = 0; i < 9; i++) {\n      const x =\n        this.startCoordinates.x +\n        this.blockWidth * (i % 3) +\n        this.blockWidth / 2;\n      const y =\n        this.startCoordinates.y +\n        this.blockHeight * Math.floor(i / 3) +\n        this.blockHeight / 2;\n\n      this.ctx.beginPath();\n      this.ctx.arc(x, y, this.style.helpCircleRadius, 0, 2 * Math.PI);\n      this.ctx.fillStyle = this.style.helpCircleFillStyle;\n      this.ctx.fill();\n    }\n\n    // Draw 0 circle\n    const x = this.startCoordinates.x + this.blockWidth + this.blockWidth / 2;\n    const y =\n      this.startCoordinates.y + this.blockHeight * 3 + this.blockHeight / 2;\n    this.ctx.beginPath();\n    this.ctx.arc(x, y, this.style.helpCircleRadius, 0, 2 * Math.PI);\n    this.ctx.fillStyle = this.style.helpCircleFillStyle;\n    this.ctx.fill();\n  }\n\n  private getNumberCoordinate(num: number): Coordinates {\n    const yIndex = Helpers.lerp(num, 1, 9, 8, 0);\n\n    if (num === 0) {\n      return {\n        x: this.startCoordinates.x + this.blockWidth + this.blockWidth / 2,\n        y:\n          this.startCoordinates.y + this.blockHeight * 3 + this.blockHeight / 2,\n      };\n    }\n\n    return {\n      x:\n        this.startCoordinates.x +\n        this.blockWidth * ((num - 1) % 3) +\n        this.blockWidth / 2,\n      y:\n        this.startCoordinates.y +\n        this.blockHeight * Math.floor(yIndex / 3) +\n        this.blockHeight / 2,\n    };\n  }\n\n  private getNumberDirection(\n    digit: number,\n    prevDigit: number\n  ): DirectionVector {\n    const coord = this.getNumberCoordinate(digit);\n    const prevCoord = this.getNumberCoordinate(prevDigit);\n\n    return {\n      x: Math.sign(prevCoord.x - coord.x) ?? 0,\n      y: Math.sign(prevCoord.y - coord.y) ?? 0,\n    } as DirectionVector;\n  }\n\n  private getStartCircleCoordinates(): Coordinates {\n    const firstCoord = this.digitsCoordinates[0];\n    const secondCoord =\n      this.digitsCoordinates.find((coord) => {\n        return !Helpers.areCoordinatesEqual(firstCoord, coord);\n      }) ?? this.digitsCoordinates[1];\n\n    const vector = Helpers.normalizeVector(\n      Helpers.getVector(firstCoord, secondCoord)\n    );\n\n    return {\n      x: firstCoord.x + vector.x * this.style.sameDirectionLineLength * -1,\n      y: firstCoord.y + vector.y * this.style.sameDirectionLineLength * -1,\n    };\n  }\n}\n","import {\n  ConsecutiveNumber,\n  Coordinates,\n  DirectionVector,\n  Vector,\n} from \"./types\";\n\nexport function lerp(\n  value: number,\n  inMin: number,\n  inMax: number,\n  outMin: number,\n  outMax: number\n) {\n  return ((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;\n}\n\nexport function splitNumberIntoDigits(n: number) {\n  return Array.from(String(n), Number);\n}\n\nexport function splitStringIntoDigits(n: string) {\n  return Array.from(n, Number);\n}\n\nexport function isSameDirection(\n  dir: DirectionVector,\n  dirToCompare: DirectionVector\n) {\n  return dir.x === dirToCompare.x && dir.y === dirToCompare.y;\n}\n\nexport function isOppositiveDirection(\n  dir: DirectionVector,\n  dirToCompare: DirectionVector\n) {\n  return dir.x * -1 === dirToCompare.x && dir.y * -1 === dirToCompare.y;\n}\n\nexport function generateArrayWithDifferentAdjacentDigits(arr: number[]) {\n  let result = [arr[0]];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] !== result[result.length - 1]) {\n      result.push(arr[i]);\n    }\n  }\n  return result;\n}\n\nexport function getConsecutiveNumbers(arr: number[]) {\n  const result: ConsecutiveNumber[] = [];\n  let currentConsecutive: ConsecutiveNumber = { digit: 0, occurence: 0 };\n  arr.toReversed().forEach((digit, index, reversedArray) => {\n    if (digit === reversedArray[index + 1]) {\n      currentConsecutive.digit = digit;\n      currentConsecutive.occurence++;\n    } else if (currentConsecutive.occurence > 0) {\n      result.push(currentConsecutive);\n      currentConsecutive = { digit: 0, occurence: 0 };\n    }\n  });\n\n  return result;\n}\n\nexport function getPerpendicularDirection(direction: DirectionVector) {\n  // If x and y are both 0, there's no perpendicular direction\n  if (direction.x === 0 && direction.y === 0) {\n    throw new Error(\"Input direction cannot be (0, 0)\");\n  }\n\n  // Perpendicular direction to (x, y) is (-y, x)\n  return { x: -direction.y, y: direction.x } as DirectionVector;\n}\n\nexport function getVector(coord1: Coordinates, coord2: Coordinates): Vector {\n  return {\n    x: coord2.x - coord1.x,\n    y: coord2.y - coord1.y,\n  };\n}\n\nexport function getPerpendicularVector(vector: Vector): Vector {\n  return {\n    x: vector.y * -1,\n    y: vector.x,\n  };\n}\n\nexport function normalizeVector(vector: { x: number; y: number }): Vector {\n  const length = Math.sqrt(vector.x ** 2 + vector.y ** 2);\n  if (length === 0) {\n    throw new Error(\"Cannot normalize a zero vector\");\n  }\n\n  return {\n    x: vector.x / length,\n    y: vector.y / length,\n  };\n}\n\nexport function getNormalizedVectorFromCoordinates(\n  coord1: Coordinates,\n  coord2: Coordinates\n): Vector {\n  return normalizeVector(getPerpendicularVector(getVector(coord1, coord2)));\n}\n\nexport function areCoordinatesEqual(coord1: Coordinates, coord2: Coordinates) {\n  return coord1.x === coord2.x && coord1.y === coord2.y;\n}\n\nexport default {\n  lerp,\n  splitNumberIntoDigits,\n  splitStringIntoDigits,\n  isSameDirection,\n  isOppositiveDirection,\n  generateArrayWithDifferentAdjacentDigits,\n  getConsecutiveNumbers,\n  getPerpendicularDirection,\n  getVector,\n  getPerpendicularVector,\n  normalizeVector,\n  getNormalizedVectorFromCoordinates,\n  areCoordinatesEqual,\n};\n"],"names":["$3c260e55dc652601$export$99d5dab9b950a0b4","coord1","coord2","x","y","$3c260e55dc652601$export$4d973b3eababff1d","vector","length","Math","sqrt","Error","$3c260e55dc652601$export$2e2bcd8739ae039","lerp","value","inMin","inMax","outMin","outMax","splitStringIntoDigits","n","Array","from","Number","isSameDirection","dir","dirToCompare","isOppositiveDirection","generateArrayWithDifferentAdjacentDigits","arr","result","i","push","getConsecutiveNumbers","currentConsecutive","digit","occurence","toReversed","forEach","index","reversedArray","getVector","normalizeVector","getNormalizedVectorFromCoordinates","areCoordinatesEqual","$f43313d21d3fd8e2$var$canvas","document","querySelector","$f43313d21d3fd8e2$var$ctx","getContext","$f43313d21d3fd8e2$var$numberInput","numberGlyph","ctx","startCoordinates","_height","_width","_digit","blockHeight","blockWidth","digitsArray","digitsCoordinates","digitsDirections","consecutiveNumbers","options","displayHelpCircles","maxDigits","style","helpCircleFillStyle","helpCircleRadius","strokeStyle","lineWidth","sameDirectionLineLength","consecutiveNumberCircleRadius","smallCircleRadius","height","width","floor","number","slice","map","el","getNumberCoordinate","getNumberDirection","draw","clearRect","drawHelpCircles","circleCoord","getStartCircleCoordinates","beginPath","arc","PI","fillStyle","fill","closePath","lineCap","lineJoin","coordinates","moveTo","lineTo","stroke","nextCoordinates","normalizedPerpendicularVector","element","direction","some","dd","endCoordinates","xOffset","yOffset","num","yIndex","prevDigit","coord","prevCoord","sign","firstCoord","secondCoord","find","clientHeight","clientWidth","addEventListener","e","target","replace"],"version":3,"file":"number-glyph.ade2e3b5.js.map"}